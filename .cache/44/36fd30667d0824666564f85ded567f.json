{"id":"node_modules/libp2p/node_modules/latency-monitor/dist/VisibilityChangeEmitter.js","dependencies":[{"name":"/home/hamster/Learning/Node.js/js-libp2p/examples/libp2p-in-the-browser2/node_modules/libp2p/node_modules/latency-monitor/dist/VisibilityChangeEmitter.js.map","includedInParent":true,"mtime":1490134783000},{"name":"/home/hamster/Learning/Node.js/js-libp2p/examples/libp2p-in-the-browser2/package.json","includedInParent":true,"mtime":1583765270259},{"name":"/home/hamster/Learning/Node.js/js-libp2p/examples/libp2p-in-the-browser2/node_modules/libp2p/node_modules/latency-monitor/package.json","includedInParent":true,"mtime":1581949153452},{"name":"events","loc":{"line":9,"column":22},"parent":"/home/hamster/Learning/Node.js/js-libp2p/examples/libp2p-in-the-browser2/node_modules/libp2p/node_modules/latency-monitor/dist/VisibilityChangeEmitter.js","resolved":"/home/hamster/Learning/Node.js/js-libp2p/examples/libp2p-in-the-browser2/node_modules/events/events.js"},{"name":"debug","loc":{"line":21,"column":20},"parent":"/home/hamster/Learning/Node.js/js-libp2p/examples/libp2p-in-the-browser2/node_modules/libp2p/node_modules/latency-monitor/dist/VisibilityChangeEmitter.js","resolved":"/home/hamster/Learning/Node.js/js-libp2p/examples/libp2p-in-the-browser2/node_modules/libp2p/node_modules/latency-monitor/node_modules/debug/src/browser.js"}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _events = require('events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* global document */\n\nvar debug = require('debug')('latency-monitor:VisibilityChangeEmitter');\n\n/**\n * Listen to page visibility change events (i.e. when the page is focused / blurred) by an event emitter.\n *\n * Warning: This does not work on all browsers, but should work on all modern browsers\n *\n * @example\n *\n *     const myVisibilityEmitter = new VisibilityChangeEmitter();\n *\n *     myVisibilityEmitter.on('visibilityChange', (pageInFocus) => {\n *        if ( pageInFocus ){\n *            // Page is in focus\n *            console.log('In focus');\n *        }\n *        else {\n *            // Page is blurred\n *            console.log('Out of focus');\n *        }\n *     });\n *     // To access the visibility state directly, call:\n *     console.log('Am I focused now? ' + myVisibilityEmitter.isVisible());\n *\n * @class VisibilityChangeEmitter\n */\n\nvar VisibilityChangeEmitter = function (_EventEmitter) {\n    _inherits(VisibilityChangeEmitter, _EventEmitter);\n\n    /**\n     * Creates a VisibilityChangeEmitter\n     */\n    function VisibilityChangeEmitter() {\n        _classCallCheck(this, VisibilityChangeEmitter);\n\n        var _this = _possibleConstructorReturn(this, (VisibilityChangeEmitter.__proto__ || Object.getPrototypeOf(VisibilityChangeEmitter)).call(this));\n\n        if (typeof document === 'undefined') {\n            debug('This is not a browser, no \"document\" found. Stopping.');\n            return _possibleConstructorReturn(_this);\n        }\n        _this._initializeVisibilityVarNames();\n        _this._addVisibilityChangeListener();\n        return _this;\n    }\n\n    /**\n     * document.hidden and document.visibilityChange are the two variables we need to check for;\n     * Since these variables are named differently in different browsers, this function sets\n     * the appropriate name based on the browser being used. Once executed, tha actual names of\n     * document.hidden and document.visibilityChange are found in this._hidden and this._visibilityChange\n     * respectively\n     * @private\n     */\n\n\n    _createClass(VisibilityChangeEmitter, [{\n        key: '_initializeVisibilityVarNames',\n        value: function _initializeVisibilityVarNames() {\n            var hidden = void 0;\n            var visibilityChange = void 0;\n            if (typeof document.hidden !== 'undefined') {\n                // Opera 12.10 and Firefox 18 and later support\n                hidden = 'hidden';\n                visibilityChange = 'visibilitychange';\n            } else if (typeof document.mozHidden !== 'undefined') {\n                hidden = 'mozHidden';\n                visibilityChange = 'mozvisibilitychange';\n            } else if (typeof document.msHidden !== 'undefined') {\n                hidden = 'msHidden';\n                visibilityChange = 'msvisibilitychange';\n            } else if (typeof document.webkitHidden !== 'undefined') {\n                hidden = 'webkitHidden';\n                visibilityChange = 'webkitvisibilitychange';\n            }\n            this._hidden = hidden;\n            this._visibilityChange = visibilityChange;\n        }\n\n        /**\n         * Adds an event listener on the document that listens to changes in document.visibilityChange\n         * (or whatever name by which the visibilityChange variable is known in the browser)\n         * @private\n         */\n\n    }, {\n        key: '_addVisibilityChangeListener',\n        value: function _addVisibilityChangeListener() {\n            if (typeof document.addEventListener === 'undefined' || typeof document[this._hidden] === 'undefined') {\n                debug('Checking page visibility requires a browser that supports the Page Visibility API.');\n            } else {\n                // Handle page visibility change\n                document.addEventListener(this._visibilityChange, this._handleVisibilityChange.bind(this), false);\n            }\n        }\n\n        /**\n         * The function returns ```true``` if the page is visible or ```false``` if the page is not visible and\n         * ```undefined``` if the page visibility API is not supported by the browser.\n         * @returns {Boolean|void} whether the page is now visible or not (undefined is unknown)\n         */\n\n    }, {\n        key: 'isVisible',\n        value: function isVisible() {\n            if (this._hidden === undefined || document[this._hidden] === undefined) {\n                return undefined;\n            }\n\n            return !document[this._hidden];\n        }\n\n        /**\n         * The function that is called when document.visibilityChange has changed\n         * It emits an event called visibilityChange and sends the value of document.hidden as a\n         * parameter\n         *\n         * @private\n         */\n\n    }, {\n        key: '_handleVisibilityChange',\n        value: function _handleVisibilityChange() {\n            var visible = !document[this._hidden];\n            debug(visible ? 'Page Visible' : 'Page Hidden');\n            // Emit the event\n            this.emit('visibilityChange', visible);\n        }\n    }]);\n\n    return VisibilityChangeEmitter;\n}(_events2.default);\n\nexports.default = VisibilityChangeEmitter;\n\n"},"sourceMaps":{"js":{"version":3,"sources":["VisibilityChangeEmitter.js"],"names":["debug","require","VisibilityChangeEmitter","document","_initializeVisibilityVarNames","_addVisibilityChangeListener","hidden","visibilityChange","mozHidden","msHidden","webkitHidden","_hidden","_visibilityChange","addEventListener","_handleVisibilityChange","bind","undefined","visible","emit"],"mappings":";;;;;;;;AAEA;;;;;;;;;;+eAFA;;AAIA,IAAMA,QAAQC,QAAQ,OAAR,EAAiB,yCAAjB,CAAd;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;IAwBqBC,uB;;;AAEjB;;;AAGA,uCAAc;AAAA;;AAAA;;AAEV,YAAI,OAAOC,QAAP,KAAoB,WAAxB,EAAqC;AACjCH,kBAAM,uDAAN;AACA;AACH;AACD,cAAKI,6BAAL;AACA,cAAKC,4BAAL;AAPU;AAQb;;AAED;;;;;;;;;;;;wDAQgC;AAC5B,gBAAIC,eAAJ;AACA,gBAAIC,yBAAJ;AACA,gBAAI,OAAOJ,SAASG,MAAhB,KAA2B,WAA/B,EAA4C;AAAE;AAC1CA,yBAAS,QAAT;AACAC,mCAAmB,kBAAnB;AACH,aAHD,MAGO,IAAI,OAAOJ,SAASK,SAAhB,KAA8B,WAAlC,EAA+C;AAClDF,yBAAS,WAAT;AACAC,mCAAmB,qBAAnB;AACH,aAHM,MAGA,IAAI,OAAOJ,SAASM,QAAhB,KAA6B,WAAjC,EAA8C;AACjDH,yBAAS,UAAT;AACAC,mCAAmB,oBAAnB;AACH,aAHM,MAGA,IAAI,OAAOJ,SAASO,YAAhB,KAAiC,WAArC,EAAkD;AACrDJ,yBAAS,cAAT;AACAC,mCAAmB,wBAAnB;AACH;AACD,iBAAKI,OAAL,GAAeL,MAAf;AACA,iBAAKM,iBAAL,GAAyBL,gBAAzB;AACH;;AAED;;;;;;;;uDAK+B;AAC3B,gBAAI,OAAOJ,SAASU,gBAAhB,KAAqC,WAArC,IACA,OAAOV,SAAS,KAAKQ,OAAd,CAAP,KAAkC,WADtC,EACmD;AAC/CX,sBAAM,oFAAN;AACH,aAHD,MAGO;AACH;AACAG,yBAASU,gBAAT,CAA0B,KAAKD,iBAA/B,EAAkD,KAAKE,uBAAL,CAA6BC,IAA7B,CAAkC,IAAlC,CAAlD,EAA2F,KAA3F;AACH;AACJ;;AAED;;;;;;;;oCAKY;AACR,gBAAI,KAAKJ,OAAL,KAAiBK,SAAjB,IAA8Bb,SAAS,KAAKQ,OAAd,MAA2BK,SAA7D,EAAwE;AACpE,uBAAOA,SAAP;AACH;;AAED,mBAAO,CAACb,SAAS,KAAKQ,OAAd,CAAR;AACH;;AAED;;;;;;;;;;kDAO0B;AACtB,gBAAMM,UAAU,CAACd,SAAS,KAAKQ,OAAd,CAAjB;AACAX,kBAAMiB,UAAU,cAAV,GAA2B,aAAjC;AACA;AACA,iBAAKC,IAAL,CAAU,kBAAV,EAA8BD,OAA9B;AACH;;;;;;kBAnFgBf,uB","file":"VisibilityChangeEmitter.js","sourcesContent":["/* global document */\n\nimport EventEmitter from 'events';\n\nconst debug = require('debug')('latency-monitor:VisibilityChangeEmitter');\n\n/**\n * Listen to page visibility change events (i.e. when the page is focused / blurred) by an event emitter.\n *\n * Warning: This does not work on all browsers, but should work on all modern browsers\n *\n * @example\n *\n *     const myVisibilityEmitter = new VisibilityChangeEmitter();\n *\n *     myVisibilityEmitter.on('visibilityChange', (pageInFocus) => {\n *        if ( pageInFocus ){\n *            // Page is in focus\n *            console.log('In focus');\n *        }\n *        else {\n *            // Page is blurred\n *            console.log('Out of focus');\n *        }\n *     });\n *     // To access the visibility state directly, call:\n *     console.log('Am I focused now? ' + myVisibilityEmitter.isVisible());\n *\n * @class VisibilityChangeEmitter\n */\nexport default class VisibilityChangeEmitter extends EventEmitter {\n\n    /**\n     * Creates a VisibilityChangeEmitter\n     */\n    constructor() {\n        super();\n        if (typeof document === 'undefined') {\n            debug('This is not a browser, no \"document\" found. Stopping.');\n            return;\n        }\n        this._initializeVisibilityVarNames();\n        this._addVisibilityChangeListener();\n    }\n\n    /**\n     * document.hidden and document.visibilityChange are the two variables we need to check for;\n     * Since these variables are named differently in different browsers, this function sets\n     * the appropriate name based on the browser being used. Once executed, tha actual names of\n     * document.hidden and document.visibilityChange are found in this._hidden and this._visibilityChange\n     * respectively\n     * @private\n     */\n    _initializeVisibilityVarNames() {\n        let hidden;\n        let visibilityChange;\n        if (typeof document.hidden !== 'undefined') { // Opera 12.10 and Firefox 18 and later support\n            hidden = 'hidden';\n            visibilityChange = 'visibilitychange';\n        } else if (typeof document.mozHidden !== 'undefined') {\n            hidden = 'mozHidden';\n            visibilityChange = 'mozvisibilitychange';\n        } else if (typeof document.msHidden !== 'undefined') {\n            hidden = 'msHidden';\n            visibilityChange = 'msvisibilitychange';\n        } else if (typeof document.webkitHidden !== 'undefined') {\n            hidden = 'webkitHidden';\n            visibilityChange = 'webkitvisibilitychange';\n        }\n        this._hidden = hidden;\n        this._visibilityChange = visibilityChange;\n    }\n\n    /**\n     * Adds an event listener on the document that listens to changes in document.visibilityChange\n     * (or whatever name by which the visibilityChange variable is known in the browser)\n     * @private\n     */\n    _addVisibilityChangeListener() {\n        if (typeof document.addEventListener === 'undefined' ||\n            typeof document[this._hidden] === 'undefined') {\n            debug('Checking page visibility requires a browser that supports the Page Visibility API.');\n        } else {\n            // Handle page visibility change\n            document.addEventListener(this._visibilityChange, this._handleVisibilityChange.bind(this), false);\n        }\n    }\n\n    /**\n     * The function returns ```true``` if the page is visible or ```false``` if the page is not visible and\n     * ```undefined``` if the page visibility API is not supported by the browser.\n     * @returns {Boolean|void} whether the page is now visible or not (undefined is unknown)\n     */\n    isVisible() {\n        if (this._hidden === undefined || document[this._hidden] === undefined) {\n            return undefined;\n        }\n\n        return !document[this._hidden];\n    }\n\n    /**\n     * The function that is called when document.visibilityChange has changed\n     * It emits an event called visibilityChange and sends the value of document.hidden as a\n     * parameter\n     *\n     * @private\n     */\n    _handleVisibilityChange() {\n        const visible = !document[this._hidden];\n        debug(visible ? 'Page Visible' : 'Page Hidden');\n        // Emit the event\n        this.emit('visibilityChange', visible);\n    }\n}\n"]}},"error":null,"hash":"ba0e96c31fad26a9f9b3487f541039df","cacheData":{"env":{}}}