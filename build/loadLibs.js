'use strict';
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var logger_js_1 = require("./logger.js");
/*
The goal of this file is to
*/
var logger = logger_js_1.mkLogger('lib');
var info = function (x) { return logger.info(x); };
var debug = function (x) { return logger.debug(x); };
var __libcache = {};
/**
 *
 * @param {array} libs Collection of file/program libs
 * @param {any} obj The file/program itself
 * @param {function} cb Callback function (after libs are loaded)
 * @param {any} rtObj The runtime object given to the file/program
 */
function loadLibsAsync(libs, obj, cb, rtObj) {
    var _loop_1 = function (n) {
        // get n'th lib and decl from program
        var lib = libs[n].lib;
        var decl = libs[n].decl;
        var key = lib + "." + decl;
        if (__libcache[key]) {
            debug('lib cache hit on: ' + key);
            obj.libs[key] = __libcache[key];
            return { value: void 0 };
        }
        // 1. Find the file -- note that we load all the libs from a default
        //    location
        var filename = "./out/" + lib + ".js";
        // 2. Load the file -- note that this is an asynchronous operation
        Promise.resolve().then(function () { return __importStar(require(filename)); }).then(function (file) {
            // 3. Get constructor function from the lib file
            var Lib = file.Lib;
            // 4. We create a "new" instance of the resulting class
            var libinstance = new Lib(rtObj);
            libinstance.loadlibs(function () {
                // 5. Execute .export() function to obtain the table note - this is a
                //    regular JS function (generated by the compiler) that we just call
                //    here 
                console.log(libinstance.export());
                rtObj.setLibloadMode(); // 2019-01-03: AA; Hack
                var table = libinstance.export().val;
                rtObj.setNormalMode(); // 2019-01-03: AA; EOH
                // 6. Lookup in the resulting table
                for (var i = 0; i < table.length; i++) {
                    var name_1 = table[i].val[0].val;
                    var libf = table[i].val[1].val;
                    if (name_1 == decl) {
                        // We store the resulting function in the object that was provided
                        // to us as an argument 
                        obj.libs[key] = libf;
                        __libcache[key] = libf;
                        break;
                    }
                }
            });
        })
            .catch(function (err) {
            // TODO: check for error! 2018-07-03: aa
            console.log(err);
        });
    };
    for (var n = 0; n < libs.length; n++) {
        var state_1 = _loop_1(n);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    // We are done processing the lib files. Transferring control back to the
    // callback. The callback is either 
    //
    // a. The next thing in the initialization, if this is the first time we
    //    are loading libraries -- typically scheduler init, etc (see `start`
    //    function in the runtime), OR
    //
    // b. The next iteration in deserialization, which is more library loading
    //    when we have several namespaces, or whatever is the deserialization
    //    callback (see `mkValue` function in the serialize module).
    cb();
}
exports.default = { loadLibsAsync: loadLibsAsync };
